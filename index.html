<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JeppCMPR v2.3.1 - PDF Comparison Tool</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: url('A_monochromatic_background_inspired_by_Jeppesen_en.png') no-repeat center center fixed;
            background-size: cover;
            min-height: 100vh;
            padding: 0;
            margin: 0;
            position: relative;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 150%;
            background: black;
            opacity: 0.8;
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 100%;
            margin: 0;
            background: rgba(43, 43, 59, 0.5);
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            min-height: 100vh;
        }

        .header {
            background: rgba(0, 86, 214, 0.9);
            color: white;
            padding: 20px 30px;
            text-align: center;
            position: relative;
            margin: 0;
            border-radius: 0;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .header p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .version-badge {
            position: absolute;
            top: 10px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .upload-section {
            padding: 40px;
            text-align: center;
            background: transparent;
        }

        .drop-zone {
            border: 3px dashed rgba(0, 86, 214, 0.8);
            border-radius: 15px;
            padding: 60px 40px;
            background: rgba(43, 43, 59, 0.9);
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 30px;
        }

        .drop-zone:hover, .drop-zone.drag-over {
            background: rgba(60, 60, 79, 0.9);
            border-color: rgba(0, 86, 214, 1);
            transform: scale(1.02);
        }

        .drop-zone-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        .drop-zone-text {
            font-size: 1.3em;
            color: rgba(0, 86, 214, 1);
            margin-bottom: 10px;
            font-weight: bold;
        }

        .drop-zone-hint {
            color: #ccc;
            font-size: 0.95em;
        }

        .btn {
            padding: 16px 40px;
            font-size: 1.15em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .btn-primary {
            background: rgba(0, 86, 214, 0.9);
            color: white;
        }

        .btn-primary:hover {
            background: rgba(0, 68, 179, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .btn-secondary {
            background: rgba(60, 60, 79, 0.8);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(60, 60, 79, 1);
        }

        .file-input {
            display: none;
        }

        .comparison-section {
            display: none;
            padding: 20px 10px;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 350px 1fr 150px;
            gap: 0;
            min-height: 600px;
        }

        .sidebar {
            background: rgba(43, 43, 59, 0.95);
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            max-height: calc(100vh - 140px);
            border-radius: 12px;
            margin: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }

        .sidebar-left {
            border-right: none;
        }

        .sidebar-right {
            border-left: none;
        }

        .sidebar h3 {
            margin-bottom: 10px;
            color: white;
            font-size: 1.2em;
        }

        .new-comparison-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background: rgba(0, 86, 214, 0.9);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .new-comparison-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .manual-pairing {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .mini-dropzone {
            flex: 1;
            border: 2px dashed #999;
            border-radius: 6px;
            padding: 8px 4px;
            text-align: center;
            font-size: 0.75em;
            font-weight: bold;
            background: rgba(60, 60, 79, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .mini-dropzone.old {
            border-color: #dc3545;
            color: #dc3545;
        }

        .mini-dropzone.new {
            border-color: #28a745;
            color: #28a745;
        }

        .mini-dropzone.drag-over {
            background: rgba(80, 80, 99, 0.6);
            transform: scale(1.05);
        }

        .mini-dropzone.old.drag-over {
            background: #ffe8e8;
        }

        .mini-dropzone.new.drag-over {
            background: #e8ffe8;
        }

        .mini-dropzone.filled {
            background: #e8f4f8;
            border-style: solid;
        }

        .mini-dropzone.old.filled {
            background: #ffe8e8;
            border-color: #dc3545;
        }

        .mini-dropzone.new.filled {
            background: #e8ffe8;
            border-color: #28a745;
        }

        .mini-dropzone-text {
            font-size: 0.85em;
        }

        .mini-dropzone-file {
            font-size: 0.7em;
            margin-top: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
        }

        .mini-dropzone-count {
            font-size: 0.75em;
            margin-top: 3px;
            font-weight: bold;
            color: rgba(0, 86, 214, 0.9);
        }

        .create-pair-btn {
            padding: 6px;
            background: rgba(0, 86, 214, 0.9);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8em;
            margin-bottom: 10px;
            transition: all 0.2s ease;
        }

        .create-pair-btn:hover:not(:disabled) {
            background: rgba(0, 68, 179, 0.9);
            transform: translateY(-1px);
        }

        .create-pair-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .sidebar-scroll {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            background: white;
        }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-item label {
            font-weight: bold;
            color: white;
            font-size: 1.0em;
        }

        .control-item input[type="range"] {
            width: 100%;
        }

        .control-item .value-display {
            text-align: center;
            font-size: 0.8em;
            color: #ccc;
        }

        .mode-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .mode-btn {
            padding: 8px;
            border: 2px solid rgba(0, 86, 214, 0.9);
            background: rgba(60, 60, 79, 0.5);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.93em;
            text-align: center;
        }

        .mode-btn.active {
            background: rgba(0, 86, 214, 0.9);
            color: white;
        }

        .view-control {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .view-buttons {
            display: flex;
            gap: 6px;
        }

        .view-btn {
            flex: 1;
            padding: 8px;
            border: 2px solid #999;
            background: rgba(60, 60, 79, 0.5);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.93em;
        }

        .view-btn.active-old {
            background: #dc3545;
            border-color: #dc3545;
            color: white;
        }

        .view-btn.active-new {
            background: #28a745;
            border-color: #28a745;
            color: white;
        }

        .auto-btn {
            padding: 8px;
            border: 2px solid #999;
            background: rgba(60, 60, 79, 0.5);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.93em;
        }

        .auto-btn.active {
            background: #007bff;
            border-color: #007bff;
            color: white;
        }

        .action-btn {
            padding: 8px;
            background: rgba(0, 86, 214, 0.9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.93em;
            transition: all 0.3s ease;
        }

        .action-btn:hover {
            background: rgba(0, 68, 179, 0.9);
        }

        .ocr-btn {
            padding: 8px;
            border: 2px solid #ffc107;
            background: rgba(60, 60, 79, 0.5);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.93em;
            text-align: center;
        }

        .ocr-btn.active {
            background: #ffc107;
            color: #000;
        }

        .ocr-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .icao-group {
            margin-bottom: 8px;
        }

        .icao-header {
            padding: 8px 10px;
            background: rgba(0, 86, 214, 0.9);
            color: white;
            font-weight: bold;
            font-size: 1.0em;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            user-select: none;
        }

        .icao-header:hover {
            transform: translateX(3px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .icao-header.unpaired-old {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .icao-header.unpaired-new {
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
        }

        .icao-header.no-icao {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
        }

        .icao-header .arrow {
            transition: transform 0.3s ease;
        }

        .icao-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        .icao-files {
            max-height: none;
            overflow: visible;
            opacity: 1;
        }

        .icao-files.hidden {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .pair-item-sidebar {
            padding: 8px;
            background: rgba(60, 60, 79, 0.5);
            margin: 3px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 2px solid transparent;
            font-size: 0.93em;
            display: flex;
            align-items: center;
            gap: 6px;
            color: white;
        }

        .pair-item-sidebar .checkbox {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(0, 86, 214, 0.9);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            background: rgba(60, 60, 79, 0.8);
            transition: all 0.2s ease;
            font-size: 10px;
        }

        .pair-item-sidebar.checked .checkbox {
            background: #28a745;
            border-color: #28a745;
        }

        .pair-item-sidebar.checked .checkbox::after {
            content: '✓';
            color: white;
            font-weight: bold;
        }

        .pair-item-sidebar:hover {
            background: rgba(80, 80, 99, 0.6);
            transform: translateX(2px);
        }

        .pair-item-sidebar.active {
            background: rgba(0, 86, 214, 0.9);
            color: white;
            border-left-color: rgba(0, 68, 179, 0.9);
        }

        .pair-item-sidebar.active-unpaired-old {
            background: #dc3545;
            color: white;
            border-left-color: #c82333;
        }

        .pair-item-sidebar.active-unpaired-new {
            background: #28a745;
            color: white;
            border-left-color: #218838;
        }

        .pair-item-sidebar.active .checkbox,
        .pair-item-sidebar.active-unpaired-old .checkbox,
        .pair-item-sidebar.active-unpaired-new .checkbox {
            border-color: white;
        }

        .pair-item-sidebar .pair-name {
            flex: 1;
            min-width: 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.3;
        }

        .pair-item-sidebar .pair-name-main {
            font-weight: bold;
        }

        .pair-item-sidebar .pair-name-pages {
            font-size: 0.9em;
            color: #ccc;
            margin-top: 2px;
        }

        .pair-item-sidebar .ocr-status {
            font-size: 0.9em;
            margin-left: auto;
        }

        .pair-item-sidebar .fuzzy-warning {
            font-size: 1.2em;
            cursor: help;
            position: relative;
        }

        .pair-item-sidebar .fuzzy-warning:hover::after {
            content: attr(data-tooltip);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #ffc107;
            color: #000;
            padding: 12px 18px;
            border-radius: 8px;
            white-space: normal;
            max-width: 300px;
            font-size: 0.8em;
            font-weight: bold;
            z-index: 99999;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            text-align: center;
        }

        .pair-item-sidebar .remove-pair-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: 4px;
        }

        .pair-item-sidebar .remove-pair-btn:hover {
            background: #c82333;
            transform: scale(1.1);
        }

        .unpaired-item-sidebar {
            padding: 6px 8px;
            background: rgba(60, 60, 79, 0.5);
            margin: 2px 0;
            border-radius: 4px;
            cursor: grab;
            transition: all 0.2s ease;
            font-size: 0.85em;
            border-left: 2px solid transparent;
            color: white;
        }

        .unpaired-item-sidebar:hover {
            background: rgba(80, 80, 99, 0.6);
            transform: translateX(2px);
        }

        .unpaired-item-sidebar.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .unpaired-item-sidebar.selected {
            background: rgba(0, 86, 214, 0.9);
            color: white;
            border-left-color: rgba(0, 68, 179, 0.9);
            font-weight: bold;
        }

        .viewer-wrapper {
            padding: 20px;
            background: rgba(43, 43, 59, 0.7);
            display: flex;
            align-items: flex-start;
            justify-content: center;
            min-height: 600px;
            position: relative;
            overflow: auto;
            z-index: 1;
        }

        .viewer-wrapper:fullscreen {
            overflow: hidden;
        }

        .sidebyside-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            width: 100%;
            height: 100%;
        }

        .sidebyside-viewer {
            position: relative;
            background: rgba(60, 60, 79, 0.5);
            border-radius: 8px;
            overflow: auto;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 10px;
        }

        .canvas-container {
            position: relative;
            display: inline-block;
            background: white;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            max-width: 100%;
            transition: transform 0.1s ease-out;
            transform-origin: 0 0;
        }

        canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .canvas-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.95em;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .sidebyside-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.95em;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .sidebyside-label.old {
            background: rgba(220, 53, 69, 0.8);
        }

        .sidebyside-label.new {
            background: rgba(40, 167, 69, 0.8);
        }

        .pdf-annotation {
            position: absolute;
            cursor: pointer;
            z-index: 9999;
        }

        .pdf-annotation-icon {
            width: 24px;
            height: 24px;
            background: #ffc107;
            border: 2px solid #ff9800;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #000;
            font-size: 14px;
        }

        .pdf-annotation-popup {
            position: fixed;
            background: #fff;
            border: 3px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            max-width: 400px;
            min-width: 200px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.4);
            z-index: 99999;
            display: none;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .pdf-annotation-popup strong {
            display: block;
            margin-bottom: 8px;
            color: #ff9800;
            font-size: 1.1em;
        }

        .pdf-annotation:hover .pdf-annotation-popup {
            display: block;
        }

        .reset-zoom-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 86, 214, 0.85);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 18px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.95em;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .reset-zoom-btn:hover {
            background: rgba(0, 86, 214, 1);
            transform: scale(1.08);
        }

        .fullscreen-toggle-btn {
            position: absolute;
            top: 55px;
            right: 10px;
            background: rgba(40, 167, 69, 0.85);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 18px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.95em;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .fullscreen-toggle-btn:hover {
            background: rgba(40, 167, 69, 1);
            transform: scale(1.08);
        }

        .exit-fullscreen-btn {
            position: absolute;
            top: 100px;
            right: 10px;
            background: rgba(43, 43, 59, 0.85);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 18px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.95em;
            z-index: 1000;
            transition: all 0.3s ease;
            box-shadow: 0 3px 12px rgba(0,0,0,0.3);
            display: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .exit-fullscreen-btn:hover {
            background: rgba(43, 43, 59, 1);
            transform: scale(1.08);
        }

        .viewer-wrapper:fullscreen .exit-fullscreen-btn {
            display: block;
        }

        .ocr-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            transform-origin: 0 0;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid rgba(0, 86, 214, 0.9);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .page-nav {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            padding: 10px;
            background: rgba(43, 43, 59, 0.9);
            border-bottom: 1px solid rgba(0, 86, 214, 0.5);
        }

        .page-nav button {
            padding: 8px 16px;
            background: rgba(0, 86, 214, 0.9);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.85em;
        }

        .page-nav button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .page-info {
            padding: 8px 16px;
            background: rgba(60, 60, 79, 0.8);
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.85em;
            color: white;
        }

        .stats-box {
            padding: 10px;
            background: rgba(60, 60, 79, 0.8);
            border-radius: 8px;
            font-size: 1.0em;
            color: white;
        }

        .stats-box div {
            margin: 4px 0;
            color: #ccc;
        }

        .stats-box strong {
            color: white;
        }

        .ocr-progress {
            font-size: 0.93em;
            color: #ffc107;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>✈️ JeppCMPR</h1>
            <p>Professional PDF Comparison Tool with Advanced Frame Alignment</p>
            <div class="version-badge">v2.3.0</div>
        </div>

        <div class="upload-section" id="uploadSection">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 20px;">
                <div>
                    <h3 style="text-align: center; margin-bottom: 15px; color: #dc3545;">📁 FOLDER OLD</h3>
                    <div class="drop-zone" id="dropZoneOld" style="border-color: #dc3545;">
                        <div class="drop-zone-icon">📥</div>
                        <div class="drop-zone-text" style="color: #dc3545;">Przeciągnij pliki OLD tutaj</div>
                        <div class="drop-zone-hint">lub użyj przycisku poniżej</div>
                    </div>
                    <button class="btn btn-primary" onclick="loadOldFolder()" style="width: 100%; margin-top: 15px; background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);">
                        📂 Wybierz pliki OLD
                    </button>
                    <div id="oldFilesCount" style="margin-top: 10px; text-align: center; color: #ccc;">Nie załadowano</div>
                </div>
                
                <div>
                    <h3 style="text-align: center; margin-bottom: 15px; color: #28a745;">📁 FOLDER NEW</h3>
                    <div class="drop-zone" id="dropZoneNew" style="border-color: #28a745;">
                        <div class="drop-zone-icon">📥</div>
                        <div class="drop-zone-text" style="color: #28a745;">Przeciągnij pliki NEW tutaj</div>
                        <div class="drop-zone-hint">lub użyj przycisku poniżej</div>
                    </div>
                    <button class="btn btn-primary" onclick="loadNewFolder()" style="width: 100%; margin-top: 15px; background: linear-gradient(135deg, #28a745 0%, #218838 100%);">
                        📂 Wybierz pliki NEW
                    </button>
                    <div id="newFilesCount" style="margin-top: 10px; text-align: center; color: #ccc;">Nie załadowano</div>
                </div>
            </div>

            <div id="compareButtonContainer" style="text-align: center; display: none;">
                <button class="btn btn-primary" onclick="startComparison()" style="padding: 20px 50px; font-size: 1.3em;">
                    🚀 Rozpocznij porównanie
                </button>
            </div>

            <input type="file" id="oldFileInput" class="file-input" accept=".pdf" multiple>
            <input type="file" id="newFileInput" class="file-input" accept=".pdf" multiple>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p id="loadingText">Ładowanie i przetwarzanie plików PDF...</p>
            <div style="width: 80%; max-width: 600px; margin: 20px auto; background: #f0f0f0; border-radius: 10px; overflow: hidden;">
                <div id="progressBar" style="height: 30px; background: rgba(0, 86, 214, 0.9); width: 0%; transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">
                    0%
                </div>
            </div>
            <p id="progressDetail" style="color: #ccc; font-size: 0.9em;">Przygotowanie...</p>
        </div>

        <div class="comparison-section" id="comparisonSection">
            <div class="comparison-grid">
                <!-- Left Sidebar -->
                <div class="sidebar sidebar-left">
                    <button class="new-comparison-btn" onclick="resetAndUpload()">🔄 Nowe porównanie</button>
                    
                    <h3>📋 Pary</h3>
                    
                    <!-- Manual Pairing Zone -->
                    <div class="manual-pairing">
                        <div class="mini-dropzone old" id="dropZoneManualOld">
                            <div class="mini-dropzone-text">🎯 OLD</div>
                            <div class="mini-dropzone-file" id="manualOldFile">przeciągnij tutaj</div>
                            <div class="mini-dropzone-count" id="manualOldCount"></div>
                        </div>
                        <div class="mini-dropzone new" id="dropZoneManualNew">
                            <div class="mini-dropzone-text">🎯 NEW</div>
                            <div class="mini-dropzone-file" id="manualNewFile">przeciągnij tutaj</div>
                            <div class="mini-dropzone-count" id="manualNewCount"></div>
                        </div>
                    </div>
                    <button class="create-pair-btn" id="createPairBtn" onclick="createManualPair()" disabled>
                        ➕ Utwórz parę
                    </button>
                    
                    <div class="sidebar-scroll" id="pairListSidebar"></div>
                    
                    <div class="stats-box">
                        <div><strong>Wszystkich:</strong> <span id="totalPairs">0</span></div>
                        <div><strong>Sprawdzonych:</strong> <span id="checkedPairs">0</span></div>
                        <div style="margin-top: 6px;"><strong>Aktualna:</strong> <span id="currentPairNum">-</span></div>
                    </div>
                </div>
                
                <!-- Main Content -->
                <div class="main-content">
                    <div class="page-nav" id="pageNav" style="display: none;">
                        <button onclick="prevPage()">⬅️ Poprzednia</button>
                        <div class="page-info" id="pageInfo">Strona 1 z 1</div>
                        <button onclick="nextPage()">Następna ➡️</button>
                    </div>

                    <div class="viewer-wrapper" id="viewerWrapper">
                        <div id="viewer"></div>
                        <div class="canvas-label" id="canvasLabel" style="display: none;"></div>
                        <button class="reset-zoom-btn" id="resetZoomBtn" style="display: none;">🔄 Reset widoku</button>
                        <button class="fullscreen-toggle-btn" id="fullscreenToggleBtn" style="display: none;" onclick="toggleFullscreen()">🖵 Pełny ekran</button>
                        <button class="exit-fullscreen-btn" id="exitFullscreenBtn" onclick="toggleFullscreen()">⚙️ Pokaż opcje</button>
                    </div>
                </div>

                <!-- Right Sidebar -->
                <div class="sidebar sidebar-right">
                    <h3>⚙️ Kontrola</h3>
                    
                    <div class="control-panel">
                        <div class="control-item">
                            <label>Obrót:</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                                <button class="action-btn" onclick="rotateMap(-90)">↶</button>
                                <button class="action-btn" onclick="rotateMap(90)">↷</button>
                            </div>
                        </div>

                        <div style="border-top: 2px solid #ddd; margin: 5px 0;"></div>

                        <div class="control-item">
                            <label>Tryb:</label>
                            <div class="mode-buttons">
                                <div class="mode-btn active" onclick="setMode('toggle')">🔄 Przełącz</div>
                                <div class="mode-btn" onclick="setMode('overlay')">🎨 Nakład</div>
                                <div class="mode-btn" onclick="setMode('sidebyside')">↔️ Obok</div>
                            </div>
                        </div>

                        <div class="control-item">
                            <label>Widok:</label>
                            <div class="view-control">
                                <button class="auto-btn" id="autoBtn" onclick="toggleAutoMode()">▶️ Auto</button>
                                <div class="view-buttons">
                                    <button class="view-btn" id="oldBtn" onclick="showOldOnly()">OLD</button>
                                    <button class="view-btn" id="newBtn" onclick="showNewOnly()">NEW</button>
                                </div>
                            </div>
                        </div>

                        <div class="control-item">
                            <label>Prędkość:</label>
                            <input type="range" id="speedRange" min="100" max="5000" value="500" step="100">
                            <div class="value-display" id="speedValue">0.5s</div>
                        </div>

                        <div class="control-item">
                            <label>OLD ← → NEW:</label>
                            <input type="range" id="opacityRange" min="0" max="100" value="50" step="5">
                            <div class="value-display" id="opacityValue">50%</div>
                        </div>

                        <div style="border-top: 2px solid #ddd; margin: 5px 0;"></div>

                        <div class="control-item">
                            <label>🔍 Analiza różnic:</label>
                            <div class="mode-buttons">
                                <button class="ocr-btn" id="ocrHybridBtn" onclick="toggleOCRMode('hybrid')" disabled>🟠 Pixel Diff</button>
                            </div>
                        </div>

                        <div class="control-item" id="sensitivityControl" style="display: none;">
                            <label>Czułość wykrywania:</label>
                            <input type="range" id="sensitivityRange" min="0" max="100" value="50" step="5">
                            <div class="value-display" id="sensitivityValue">50%</div>
                            <div style="font-size: 0.75em; color: #ccc; margin-top: 5px; line-height: 1.3;">
                                <strong>0%:</strong> Wykrywa WSZYSTKO (nawet drobne różnice)<br>
                                <strong>50%:</strong> ✅ Zbalansowane (zalecane!)<br>
                                <strong>100%:</strong> Tylko DUŻE różnice<br>
                                <em>minArea = 25px (stałe)</em>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfPairs = [];
        let unpairedOld = [];
        let unpairedNew = [];
        let currentPairIndex = 0;
        let currentPageIndex = 0;
        let autoToggleInterval = null;
        let currentMode = 'toggle';
        let viewMode = 'auto';
        let showingOld = true;
        let checkedPairs = new Set();
        let oldFiles = [];
        let newFiles = [];
        let syncState = { zoom: 1, panX: 0, panY: 0 };
        let selectedUnpairedOldIndex = null;
        let selectedUnpairedOldPage = null;
        let selectedUnpairedNewIndex = null;
        let selectedUnpairedNewPage = null;
        
        let ocrMode = null;
        let ocrResults = new Map();
        let currentRotation = 0;

        // FIX #4: Manual pairing with proper file tracking
        let manualPairingOldFiles = [];
        let manualPairingNewFiles = [];
        
        // Alignment offsets
        let alignmentOffsets = new Map();
        
        // PDF annotations cache
        let pdfAnnotations = new Map();

        const dropZoneOld = document.getElementById('dropZoneOld');
        const dropZoneNew = document.getElementById('dropZoneNew');
        const oldFileInput = document.getElementById('oldFileInput');
        const newFileInput = document.getElementById('newFileInput');

        dropZoneOld.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZoneOld.classList.add('drag-over');
        });

        dropZoneOld.addEventListener('dragleave', () => {
            dropZoneOld.classList.remove('drag-over');
        });

        dropZoneOld.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZoneOld.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.pdf'));
            if (files.length > 0) {
                oldFiles = files;
                updateFileInfo();
            }
        });

        dropZoneNew.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZoneNew.classList.add('drag-over');
        });

        dropZoneNew.addEventListener('dragleave', () => {
            dropZoneNew.classList.remove('drag-over');
        });

        dropZoneNew.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZoneNew.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.pdf'));
            if (files.length > 0) {
                newFiles = files;
                updateFileInfo();
            }
        });

        oldFileInput.addEventListener('change', (e) => {
            oldFiles = Array.from(e.target.files).filter(f => f.name.endsWith('.pdf'));
            updateFileInfo();
        });

        newFileInput.addEventListener('change', (e) => {
            newFiles = Array.from(e.target.files).filter(f => f.name.endsWith('.pdf'));
            updateFileInfo();
        });

        // FIX #4: Manual pairing dropzones with FILE SUPPORT (not just drag from sidebar)
        const dropZoneManualOld = document.getElementById('dropZoneManualOld');
        const dropZoneManualNew = document.getElementById('dropZoneManualNew');

        dropZoneManualOld.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZoneManualOld.classList.add('drag-over');
        });

        dropZoneManualOld.addEventListener('dragleave', () => {
            dropZoneManualOld.classList.remove('drag-over');
        });

        dropZoneManualOld.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZoneManualOld.classList.remove('drag-over');
            
            // Check if it's from sidebar or external files
            const data = e.dataTransfer.getData('text/plain');
            if (data.startsWith('unpaired-old-')) {
                const index = parseInt(data.replace('unpaired-old-', ''));
                manualPairingOldFiles = [unpairedOld[index]];
            } else {
                // External files dropped
                const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.pdf'));
                if (files.length > 0) {
                    // Load PDFs
                    const loadedFiles = [];
                    for (let file of files) {
                        try {
                            const arrayBuffer = await file.arrayBuffer();
                            const doc = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                            loadedFiles.push({
                                name: file.name,
                                file: file,
                                doc: doc,
                                totalPages: doc.numPages
                            });
                        } catch (error) {
                            console.error(`Error loading ${file.name}:`, error);
                        }
                    }
                    manualPairingOldFiles = loadedFiles;
                }
            }
            updateManualPairingUI();
        });

        dropZoneManualNew.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZoneManualNew.classList.add('drag-over');
        });

        dropZoneManualNew.addEventListener('dragleave', () => {
            dropZoneManualNew.classList.remove('drag-over');
        });

        dropZoneManualNew.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZoneManualNew.classList.remove('drag-over');
            
            const data = e.dataTransfer.getData('text/plain');
            if (data.startsWith('unpaired-new-')) {
                const index = parseInt(data.replace('unpaired-new-', ''));
                manualPairingNewFiles = [unpairedNew[index]];
            } else {
                // External files dropped
                const files = Array.from(e.dataTransfer.files).filter(f => f.name.endsWith('.pdf'));
                if (files.length > 0) {
                    const loadedFiles = [];
                    for (let file of files) {
                        try {
                            const arrayBuffer = await file.arrayBuffer();
                            const doc = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                            loadedFiles.push({
                                name: file.name,
                                file: file,
                                doc: doc,
                                totalPages: doc.numPages
                            });
                        } catch (error) {
                            console.error(`Error loading ${file.name}:`, error);
                        }
                    }
                    manualPairingNewFiles = loadedFiles;
                }
            }
            updateManualPairingUI();
        });

        // FIX #4: Show file count and enable button properly
        function updateManualPairingUI() {
            const oldFileEl = document.getElementById('manualOldFile');
            const newFileEl = document.getElementById('manualNewFile');
            const oldCountEl = document.getElementById('manualOldCount');
            const newCountEl = document.getElementById('manualNewCount');
            const createBtn = document.getElementById('createPairBtn');
            const oldZone = document.getElementById('dropZoneManualOld');
            const newZone = document.getElementById('dropZoneManualNew');

            if (manualPairingOldFiles.length > 0) {
                if (manualPairingOldFiles.length === 1) {
                    oldFileEl.textContent = manualPairingOldFiles[0].name.substring(0, 20) + '...';
                } else {
                    oldFileEl.textContent = 'Wiele plików';
                }
                oldCountEl.textContent = `${manualPairingOldFiles.length} plik(ów)`;
                oldZone.classList.add('filled');
            } else {
                oldFileEl.textContent = 'przeciągnij tutaj';
                oldCountEl.textContent = '';
                oldZone.classList.remove('filled');
            }

            if (manualPairingNewFiles.length > 0) {
                if (manualPairingNewFiles.length === 1) {
                    newFileEl.textContent = manualPairingNewFiles[0].name.substring(0, 20) + '...';
                } else {
                    newFileEl.textContent = 'Wiele plików';
                }
                newCountEl.textContent = `${manualPairingNewFiles.length} plik(ów)`;
                newZone.classList.add('filled');
            } else {
                newFileEl.textContent = 'przeciągnij tutaj';
                newCountEl.textContent = '';
                newZone.classList.remove('filled');
            }

            // Enable button when BOTH have files
            createBtn.disabled = !(manualPairingOldFiles.length > 0 && manualPairingNewFiles.length > 0);
        }

        async function createManualPair() {
            if (manualPairingOldFiles.length === 0 || manualPairingNewFiles.length === 0) return;

            // Create pairs from the files
            const minLength = Math.min(manualPairingOldFiles.length, manualPairingNewFiles.length);
            
            for (let i = 0; i < minLength; i++) {
                const oldItem = manualPairingOldFiles[i];
                const newItem = manualPairingNewFiles[i];
                
                const icao = extractICAO(oldItem.name) || extractICAO(newItem.name) || '';

                const newPair = {
                    name: `${oldItem.name} + ${newItem.name}`,
                    icao: icao,
                    oldFile: oldItem.file,
                    newFile: newItem.file,
                    oldDoc: oldItem.doc,
                    newDoc: newItem.doc,
                    totalPages: Math.max(oldItem.totalPages, newItem.totalPages),
                    isPaired: true,
                    isManual: true
                };

                pdfPairs.push(newPair);

                // Remove from unpaired lists if they were there
                const oldIndex = unpairedOld.findIndex(u => u.name === oldItem.name);
                if (oldIndex > -1) unpairedOld.splice(oldIndex, 1);

                const newIndex = unpairedNew.findIndex(u => u.name === newItem.name);
                if (newIndex > -1) unpairedNew.splice(newIndex, 1);

                const pairIndex = pdfPairs.length - 1;
                await calculateFrameAlignment(pairIndex);
            }

            manualPairingOldFiles = [];
            manualPairingNewFiles = [];
            updateManualPairingUI();
            renderPairList();
            updateStats();

            await loadPair(pdfPairs.length - 1);
        }

        function extractICAO(filename) {
            const cleanName = filename.replace(/^AD\s*2-?/i, '').trim();
            const match = cleanName.match(/^([A-Z]{4})/);
            return match ? match[1] : '';
        }

        function removePair(index) {
            if (index < 0 || index >= pdfPairs.length) return;

            const pair = pdfPairs[index];

            if (pair.isManual) {
                unpairedOld.push({
                    name: pair.oldFile.name,
                    file: pair.oldFile,
                    doc: pair.oldDoc,
                    totalPages: pair.oldDoc.numPages
                });

                unpairedNew.push({
                    name: pair.newFile.name,
                    file: pair.newFile,
                    doc: pair.newDoc,
                    totalPages: pair.newDoc.numPages
                });

                unpairedOld.sort((a, b) => a.name.localeCompare(b.name));
                unpairedNew.sort((a, b) => a.name.localeCompare(b.name));
            }

            pdfPairs.splice(index, 1);
            checkedPairs.delete(index);

            const newChecked = new Set();
            checkedPairs.forEach(i => {
                if (i > index) newChecked.add(i - 1);
                else if (i < index) newChecked.add(i);
            });
            checkedPairs = newChecked;

            if (pdfPairs.length > 0) {
                const newIndex = Math.min(index, pdfPairs.length - 1);
                loadPair(newIndex);
            }

            renderPairList();
            updateStats();
        }

        function updateFileInfo() {
            const oldCount = document.getElementById('oldFilesCount');
            const newCount = document.getElementById('newFilesCount');
            const compareContainer = document.getElementById('compareButtonContainer');

            if (oldFiles.length > 0) {
                oldCount.textContent = `✅ Załadowano ${oldFiles.length} plików`;
                oldCount.style.color = '#28a745';
                oldCount.style.fontWeight = 'bold';
            } else {
                oldCount.textContent = '❌ Nie załadowano';
                oldCount.style.color = '#999';
            }

            if (newFiles.length > 0) {
                newCount.textContent = `✅ Załadowano ${newFiles.length} plików`;
                newCount.style.color = '#28a745';
                newCount.style.fontWeight = 'bold';
            } else {
                newCount.textContent = '❌ Nie załadowano';
                newCount.style.color = '#999';
            }

            compareContainer.style.display = (oldFiles.length > 0 && newFiles.length > 0) ? 'block' : 'none';
        }

        function startComparison() {
            processFiles(oldFiles, newFiles);
        }

        function loadOldFolder() {
            oldFileInput.click();
        }

        function loadNewFolder() {
            newFileInput.click();
        }

        function levenshteinDistance(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            const matrix = [];

            for (let i = 0; i <= len1; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= len2; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (str1.charAt(i - 1) === str2.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }

            return matrix[len1][len2];
        }

        function fuzzyMatch(oldFiles, newFiles) {
            const pairs = [];
            const unmatchedOld = [...oldFiles];
            const unmatchedNew = [...newFiles];

            for (let i = unmatchedOld.length - 1; i >= 0; i--) {
                for (let j = unmatchedNew.length - 1; j >= 0; j--) {
                    if (unmatchedOld[i].name === unmatchedNew[j].name) {
                        pairs.push({
                            oldFile: unmatchedOld[i],
                            newFile: unmatchedNew[j],
                            distance: 0
                        });
                        unmatchedOld.splice(i, 1);
                        unmatchedNew.splice(j, 1);
                        break;
                    }
                }
            }

            for (const oldFile of unmatchedOld) {
                let bestMatch = null;
                let bestDistance = Infinity;

                for (const newFile of unmatchedNew) {
                    const distance = levenshteinDistance(oldFile.name, newFile.name);
                    const maxLen = Math.max(oldFile.name.length, newFile.name.length);
                    const similarity = 1 - (distance / maxLen);

                    if (similarity >= 0.7 && distance < bestDistance) {
                        bestMatch = newFile;
                        bestDistance = distance;
                    }
                }

                if (bestMatch) {
                    pairs.push({
                        oldFile: oldFile,
                        newFile: bestMatch,
                        distance: bestDistance
                    });

                    const idx = unmatchedNew.indexOf(bestMatch);
                    if (idx > -1) unmatchedNew.splice(idx, 1);
                }
            }

            const finalOld = unmatchedOld.filter(f => {
                return !pairs.some(p => p.oldFile === f);
            });

            const finalNew = unmatchedNew.filter(f => {
                return !pairs.some(p => p.newFile === f);
            });

            return { pairs, unpairedOld: finalOld, unpairedNew: finalNew };
        }

        async function processFiles(oldFilesList, newFilesList) {
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('loading').style.display = 'block';

            const updateProgress = (percent, text) => {
                const bar = document.getElementById('progressBar');
                const detail = document.getElementById('progressDetail');
                bar.style.width = percent + '%';
                bar.textContent = Math.round(percent) + '%';
                detail.textContent = text;
            };

            updateProgress(0, 'Filtrowanie plików...');
            await new Promise(resolve => setTimeout(resolve, 100));

            const filterFile = (file) => {
                const name = file.name.toUpperCase();
                return !name.includes('CHARACTERISTICS') && 
                       !name.includes('GEN') && 
                       !name.includes('ENR');
            };

            const filteredOldFiles = oldFilesList.filter(filterFile);
            const filteredNewFiles = newFilesList.filter(filterFile);

            updateProgress(10, 'Inteligentne dopasowywanie par (Fuzzy Matching)...');

            const { pairs: matchedPairs, unpairedOld: unmatchedOld, unpairedNew: unmatchedNew } = 
                fuzzyMatch(filteredOldFiles, filteredNewFiles);

            updateProgress(15, 'Ładowanie plików PDF...');

            const totalFiles = (matchedPairs.length * 2) + unmatchedOld.length + unmatchedNew.length;
            let loadedFiles = 0;

            const pairs = [];
            for (let match of matchedPairs) {
                try {
                    const oldArrayBuffer = await match.oldFile.arrayBuffer();
                    const oldDoc = await pdfjsLib.getDocument({data: oldArrayBuffer}).promise;
                    loadedFiles++;
                    updateProgress(15 + (loadedFiles / totalFiles * 50), `Ładowanie par...`);
                    
                    const newArrayBuffer = await match.newFile.arrayBuffer();
                    const newDoc = await pdfjsLib.getDocument({data: newArrayBuffer}).promise;
                    loadedFiles++;
                    updateProgress(15 + (loadedFiles / totalFiles * 50), `Ładowanie par...`);
                    
                    const icao = extractICAO(match.oldFile.name) || extractICAO(match.newFile.name) || '';

                    pairs.push({
                        name: match.oldFile.name,
                        icao: icao,
                        oldFile: match.oldFile,
                        newFile: match.newFile,
                        oldDoc: oldDoc,
                        newDoc: newDoc,
                        totalPages: Math.max(oldDoc.numPages, newDoc.numPages),
                        isPaired: true,
                        fuzzyDistance: match.distance
                    });
                } catch (error) {
                    console.error(`Error loading pair:`, error);
                }
            }

            pairs.sort((a, b) => {
                if (a.icao !== b.icao) return a.icao.localeCompare(b.icao);
                return a.name.localeCompare(b.name);
            });

            const unpairedOldItems = [];
            for (let file of unmatchedOld) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const doc = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                    unpairedOldItems.push({
                        name: file.name,
                        file: file,
                        doc: doc,
                        totalPages: doc.numPages
                    });
                    loadedFiles++;
                    updateProgress(15 + (loadedFiles / totalFiles * 50), `Ładowanie OLD...`);
                } catch (error) {
                    console.error(`Error loading ${file.name}:`, error);
                }
            }

            const unpairedNewItems = [];
            for (let file of unmatchedNew) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const doc = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                    unpairedNewItems.push({
                        name: file.name,
                        file: file,
                        doc: doc,
                        totalPages: doc.numPages
                    });
                    loadedFiles++;
                    updateProgress(15 + (loadedFiles / totalFiles * 50), `Ładowanie NEW...`);
                } catch (error) {
                    console.error(`Error loading ${file.name}:`, error);
                }
            }

            pdfPairs = pairs;
            unpairedOld = unpairedOldItems;
            unpairedNew = unpairedNewItems;

            // FIX #2: MAXIMUM FRAME ALIGNMENT (sub-pixel precision)
            updateProgress(65, 'MAKSYMALNE dopasowanie ramek (sub-pixel precision)...');
            for (let i = 0; i < pdfPairs.length; i++) {
                await calculateFrameAlignment(i);
                updateProgress(65 + (i / pdfPairs.length * 10), `Wyrównywanie ramek ${i + 1}/${pdfPairs.length}...`);
            }

            updateProgress(100, 'Gotowe!');
            await new Promise(resolve => setTimeout(resolve, 500));

            document.getElementById('loading').style.display = 'none';
            document.getElementById('comparisonSection').style.display = 'block';

            renderPairList();
            updateStats();
            
            if (pdfPairs.length > 0) {
                document.getElementById('ocrHybridBtn').disabled = false;
                
                await loadPair(0);
                
                setTimeout(() => {
                    toggleAutoMode();
                }, 500);
            }
        }

        // FIX #2: MAXIMUM FRAME ALIGNMENT with sub-pixel precision
        async function calculateFrameAlignment(pairIndex) {
            const pair = pdfPairs[pairIndex];
            if (!pair) return;

            try {
                const scale = 2.0; // Higher scale for even better precision

                const oldCanvas = document.createElement('canvas');
                const oldPage = await pair.oldDoc.getPage(1);
                const oldViewport = oldPage.getViewport({scale: scale});
                oldCanvas.width = oldViewport.width;
                oldCanvas.height = oldViewport.height;
                const oldCtx = oldCanvas.getContext('2d');
                await oldPage.render({canvasContext: oldCtx, viewport: oldViewport}).promise;

                const newCanvas = document.createElement('canvas');
                const newPage = await pair.newDoc.getPage(1);
                const newViewport = newPage.getViewport({scale: scale});
                newCanvas.width = newViewport.width;
                newCanvas.height = newViewport.height;
                const newCtx = newCanvas.getContext('2d');
                await newPage.render({canvasContext: newCtx, viewport: newViewport}).promise;

                const oldFrame = detectFrameMaximum(oldCtx, oldCanvas.width, oldCanvas.height);
                const newFrame = detectFrameMaximum(newCtx, newCanvas.width, newCanvas.height);

                const offsetX = oldFrame.x - newFrame.x;
                const offsetY = oldFrame.y - newFrame.y;

                const scaleX = oldFrame.width / newFrame.width;
                const scaleY = oldFrame.height / newFrame.height;

                const displayScale = 3.0 / scale;
                alignmentOffsets.set(pairIndex, {
                    offsetX: offsetX * displayScale,
                    offsetY: offsetY * displayScale,
                    scaleX: scaleX,
                    scaleY: scaleY
                });

            } catch (error) {
                console.error(`Frame alignment error for pair ${pairIndex}:`, error);
                alignmentOffsets.set(pairIndex, {
                    offsetX: 0,
                    offsetY: 0,
                    scaleX: 1,
                    scaleY: 1
                });
            }
        }

        // FIX #2: MAXIMUM frame detection with sub-pixel accuracy
        function detectFrameMaximum(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // ULTRA-SENSITIVE edge detection
            const edges = new Uint8Array(width * height);
            const edgeThreshold = 20; // Zwiększony próg - mniej szumów
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const i = (y * width + x) * 4;
                    
                    const left = (y * width + (x - 1)) * 4;
                    const right = (y * width + (x + 1)) * 4;
                    const up = ((y - 1) * width + x) * 4;
                    const down = ((y + 1) * width + x) * 4;
                    
                    const gx = Math.abs(data[right] - data[left]);
                    const gy = Math.abs(data[down] - data[up]);
                    const gradient = Math.sqrt(gx * gx + gy * gy);
                    
                    if (gradient > edgeThreshold) {
                        edges[y * width + x] = 1;
                    }
                }
            }
            
            const horizontalLines = [];
            const verticalLines = [];
            
            // Detect horizontal lines with MAXIMUM tolerance
            for (let y = 0; y < height; y++) {
                let lineLength = 0;
                let lineStart = 0;
                let gapTolerance = 0;
                const maxGap = 15; // Zmniejszony gap - bardziej precyzyjne linie
                
                for (let x = 0; x < width; x++) {
                    if (edges[y * width + x] === 1) {
                        if (lineLength === 0) lineStart = x;
                        lineLength++;
                        gapTolerance = 0;
                    } else {
                        if (lineLength > 0) {
                            gapTolerance++;
                            if (gapTolerance > maxGap) {
                                if (lineLength > width * 0.4) { // 40% threshold - bardziej restrykcyjne
                                    horizontalLines.push({y: y, x1: lineStart, x2: lineStart + lineLength, strength: lineLength});
                                }
                                lineLength = 0;
                                gapTolerance = 0;
                            } else {
                                lineLength++;
                            }
                        }
                    }
                }
                if (lineLength > width * 0.4) {
                    horizontalLines.push({y: y, x1: lineStart, x2: lineStart + lineLength, strength: lineLength});
                }
            }
            
            // Detect vertical lines with MAXIMUM tolerance
            for (let x = 0; x < width; x++) {
                let lineLength = 0;
                let lineStart = 0;
                let gapTolerance = 0;
                const maxGap = 15;
                
                for (let y = 0; y < height; y++) {
                    if (edges[y * width + x] === 1) {
                        if (lineLength === 0) lineStart = y;
                        lineLength++;
                        gapTolerance = 0;
                    } else {
                        if (lineLength > 0) {
                            gapTolerance++;
                            if (gapTolerance > maxGap) {
                                if (lineLength > height * 0.4) {
                                    verticalLines.push({x: x, y1: lineStart, y2: lineStart + lineLength, strength: lineLength});
                                }
                                lineLength = 0;
                                gapTolerance = 0;
                            } else {
                                lineLength++;
                            }
                        }
                    }
                }
                if (lineLength > height * 0.4) {
                    verticalLines.push({x: x, y1: lineStart, y2: lineStart + lineLength, strength: lineLength});
                }
            }
            
            if (horizontalLines.length < 2 || verticalLines.length < 2) {
                return detectContentBBox(ctx, width, height);
            }
            
            // Sort by strength (longest lines first)
            horizontalLines.sort((a, b) => b.strength - a.strength);
            verticalLines.sort((a, b) => b.strength - a.strength);
            
            // Find OUTERMOST strong lines in each region
            let topLine = null;
            let bottomLine = null;
            let leftLine = null;
            let rightLine = null;
            
            // Top line - look in top 20% of image
            for (let line of horizontalLines) {
                if (line.y < height * 0.2) {
                    topLine = line;
                    break;
                }
            }
            if (!topLine) topLine = horizontalLines[0];
            
            // Bottom line - look in bottom 20% of image
            for (let line of horizontalLines) {
                if (line.y > height * 0.8) {
                    bottomLine = line;
                    break;
                }
            }
            if (!bottomLine) bottomLine = horizontalLines[horizontalLines.length - 1];
            
            // Left line - look in left 20% of image
            for (let line of verticalLines) {
                if (line.x < width * 0.2) {
                    leftLine = line;
                    break;
                }
            }
            if (!leftLine) leftLine = verticalLines[0];
            
            // Right line - look in right 20% of image
            for (let line of verticalLines) {
                if (line.x > width * 0.8) {
                    rightLine = line;
                    break;
                }
            }
            if (!rightLine) rightLine = verticalLines[verticalLines.length - 1];
            
            return {
                x: leftLine.x,
                y: topLine.y,
                width: rightLine.x - leftLine.x,
                height: bottomLine.y - topLine.y
            };
        }

        function detectContentBBox(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            const threshold = 240;
            
            let minX = width, maxX = 0;
            let minY = height, maxY = 0;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    if (r < threshold || g < threshold || b < threshold) {
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            const padding = 10;
            return {
                x: Math.max(0, minX - padding),
                y: Math.max(0, minY - padding),
                width: Math.min(width, maxX + padding) - Math.max(0, minX - padding),
                height: Math.min(height, maxY + padding) - Math.max(0, minY - padding)
            };
        }

        async function extractPDFAnnotations(pdfDoc, pageNum) {
            try {
                const page = await pdfDoc.getPage(pageNum);
                const annotations = await page.getAnnotations();
                
                const results = [];
                for (const annotation of annotations) {
                    if (annotation.subtype === 'Text' || annotation.subtype === 'FreeText' || annotation.subtype === 'Popup') {
                        // Próbuj różne właściwości dla treści
                        const contents = annotation.contents 
                            || annotation.contentsObj?.str 
                            || annotation.richText 
                            || annotation.rc 
                            || '';
                        
                        const title = annotation.title 
                            || annotation.titleObj?.str 
                            || annotation.name 
                            || 'Komentarz';
                        
                        if (contents || title !== 'Komentarz') {
                            results.push({
                                type: annotation.subtype,
                                rect: annotation.rect,
                                contents: contents,
                                title: title,
                                raw: annotation // dla debugowania
                            });
                        }
                    }
                }
                
                // Log dla debugowania
                if (results.length > 0) {
                    console.log('Znaleziono annotacje:', results);
                }
                
                return results;
            } catch (error) {
                console.error('Error extracting annotations:', error);
                return [];
            }
        }

        // FIX #4b: PROPER Adobe comment content display
        async function renderPDFAnnotations(container, pdfDoc, pageNum, canvasWidth, canvasHeight) {
            const annotations = await extractPDFAnnotations(pdfDoc, pageNum);
            
            annotations.forEach(annot => {
                const annotDiv = document.createElement('div');
                annotDiv.className = 'pdf-annotation';
                
                const scale = canvasWidth / 595;
                const x = annot.rect[0] * scale;
                const y = canvasHeight - (annot.rect[3] * scale);
                
                annotDiv.style.left = x + 'px';
                annotDiv.style.top = y + 'px';
                
                const icon = document.createElement('div');
                icon.className = 'pdf-annotation-icon';
                icon.textContent = '💬';
                annotDiv.appendChild(icon);
                
                const popup = document.createElement('div');
                popup.className = 'pdf-annotation-popup';
                
                // FIX: Display actual content, not just "Comment"
                const title = annot.title || 'Komentarz';
                const content = annot.contents || '(brak treści)';
                popup.innerHTML = `<strong>${title}:</strong> ${content}`;
                
                annotDiv.addEventListener('mouseenter', (e) => {
                    popup.style.display = 'block';
                    popup.style.left = (e.clientX + 15) + 'px';
                    popup.style.top = (e.clientY + 15) + 'px';
                });
                
                annotDiv.addEventListener('mousemove', (e) => {
                    popup.style.left = (e.clientX + 15) + 'px';
                    popup.style.top = (e.clientY + 15) + 'px';
                });
                
                annotDiv.addEventListener('mouseleave', () => {
                    popup.style.display = 'none';
                });
                
                document.body.appendChild(popup);
                container.appendChild(annotDiv);
            });
        }

        function comparePixels(oldCanvas, newCanvas, pageNum) {
            const differences = [];
            const sensitivityValue = document.getElementById('sensitivityRange').value;
            
            // ODWRÓCONA LOGIKA - intuicyjna:
            // Im WYŻSZA czułość (100%), tym NIŻSZY threshold, tym WIĘCEJ wykrywa
            // 100% czułości → threshold 0 (wykrywa wszystko, nawet małe różnice)
            // 0% czułości → threshold 255 (wykrywa mało, tylko duże różnice)
            const threshold = (100 - sensitivityValue) * 2.55;
            
            // Obniżone minArea - wykrywa mniejsze regiony
            const minArea = 5;
            
            const coordinateScale = 1.5;
            
            const oldCtx = oldCanvas.getContext('2d', { willReadFrequently: true });
            const newCtx = newCanvas.getContext('2d', { willReadFrequently: true });
            
            const oldData = oldCtx.getImageData(0, 0, oldCanvas.width, oldCanvas.height);
            const newData = newCtx.getImageData(0, 0, newCanvas.width, newCanvas.height);
            
            const width = Math.min(oldCanvas.width, newCanvas.width);
            const height = Math.min(oldCanvas.height, newCanvas.height);
            
            // Tworzymy nowy canvas z różnicami - bezpośrednie kolorowanie
            const diffCanvas = document.createElement('canvas');
            diffCanvas.width = width;
            diffCanvas.height = height;
            const diffCtx = diffCanvas.getContext('2d');
            const diffData = diffCtx.createImageData(width, height);
            
            let differenceCount = 0;
            const diffMap = new Uint8Array(width * height); // Mapa pikseli z różnicami dla flood fill
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    
                    const r1 = oldData.data[i];
                    const g1 = oldData.data[i + 1];
                    const b1 = oldData.data[i + 2];
                    
                    const r2 = newData.data[i];
                    const g2 = newData.data[i + 1];
                    const b2 = newData.data[i + 2];
                    
                    // Oblicz luminance (jasność) dla OLD i NEW
                    const luminance1 = 0.299 * r1 + 0.587 * g1 + 0.114 * b1;
                    const luminance2 = 0.299 * r2 + 0.587 * g2 + 0.114 * b2;
                    
                    // Progi jasności - złagodzone dla lepszego wykrywania
                    const veryDarkThreshold = 80;   // Poniżej = bardzo ciemny
                    const veryLightThreshold = 175; // Powyżej = bardzo jasny
                    
                    const isVeryDark1 = luminance1 < veryDarkThreshold;
                    const isVeryLight1 = luminance1 > veryLightThreshold;
                    const isVeryDark2 = luminance2 < veryDarkThreshold;
                    const isVeryLight2 = luminance2 > veryLightThreshold;
                    
                    // Wykrywaj TYLKO zmiany: bardzo jasny↔bardzo ciemny
                    const isLightToDark = isVeryLight1 && isVeryDark2; // bardzo jasny→bardzo ciemny
                    const isDarkToLight = isVeryDark1 && isVeryLight2; // bardzo ciemny→bardzo jasny
                    
                    const diff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);
                    
                    if (diff > threshold && (isLightToDark || isDarkToLight)) {
                        differenceCount++;
                        diffMap[y * width + x] = 1; // Oznacz piksel jako różny
                        
                        // Podświetl różnicę pomarańczowym
                        diffData.data[i] = 255;      // R
                        diffData.data[i + 1] = 140;  // G - pomarańczowy
                        diffData.data[i + 2] = 0;    // B
                        diffData.data[i + 3] = 180;  // Alpha (przezroczystość)
                    } else {
                        // PRZEZROCZYSTOŚĆ - żeby było widać mapy przełączające się pod spodem
                        diffData.data[i] = 0;
                        diffData.data[i + 1] = 0;
                        diffData.data[i + 2] = 0;
                        diffData.data[i + 3] = 0;    // Alpha = 0 (całkowicie przezroczyste)
                    }
                }
            }
            
            diffCtx.putImageData(diffData, 0, 0);
            
            // Znajdź regiony zmian dla żółtych kółek
            const regions = [];
            const visited = new Uint8Array(width * height);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    if (diffMap[idx] === 1 && visited[idx] === 0) {
                        const region = floodFill(diffMap, visited, x, y, width, height);
                        
                        // Filtruj według stałego minArea
                        if (region.area >= minArea) {
                            regions.push({
                                centerX: (region.minX + region.maxX) / 2,
                                centerY: (region.minY + region.maxY) / 2,
                                width: region.maxX - region.minX,
                                height: region.maxY - region.minY,
                                area: region.area,
                                minX: region.minX,
                                maxX: region.maxX,
                                minY: region.minY,
                                maxY: region.maxY
                            });
                        }
                    }
                }
            }
            
            // KLUCZOWE: Nałóż żółty zakreślacz BEZPOŚREDNIO na piksele - tylko na jasne obszary!
            if (regions.length > 0) {
                // Pobierz dane z diffCanvas
                const finalDiffData = diffCtx.getImageData(0, 0, width, height);
                
                regions.forEach(region => {
                    const regionSize = Math.max(region.width, region.height);
                    let baseRadius = regionSize * 0.9;
                    baseRadius = Math.max(baseRadius, 25);
                    
                    // Dla każdego piksela w bounding box regionu
                    for (let y = Math.max(0, Math.floor(region.minY - baseRadius)); y <= Math.min(height - 1, Math.ceil(region.maxY + baseRadius)); y++) {
                        for (let x = Math.max(0, Math.floor(region.minX - baseRadius)); x <= Math.min(width - 1, Math.ceil(region.maxX + baseRadius)); x++) {
                            // Sprawdź czy piksel jest w którymś kółku tego regionu
                            let inCircle = false;
                            
                            if (regionSize > 60) {
                                const numCirclesX = Math.ceil(region.width / 45);
                                const numCirclesY = Math.ceil(region.height / 45);
                                
                                for (let cy = 0; cy < numCirclesY && !inCircle; cy++) {
                                    for (let cx = 0; cx < numCirclesX && !inCircle; cx++) {
                                        const circleX = region.minX + (cx + 0.5) * (region.width / numCirclesX);
                                        const circleY = region.minY + (cy + 0.5) * (region.height / numCirclesY);
                                        const dist = Math.sqrt((x - circleX) ** 2 + (y - circleY) ** 2);
                                        if (dist <= 28) inCircle = true;
                                    }
                                }
                            } else {
                                const dist = Math.sqrt((x - region.centerX) ** 2 + (y - region.centerY) ** 2);
                                if (dist <= baseRadius) inCircle = true;
                            }
                            
                            if (inCircle) {
                                const i = (y * width + x) * 4;
                                
                                // Jeśli piksel ma już pomarańczową różnicę - NIE nadpisuj!
                                if (finalDiffData.data[i + 3] === 180) continue;
                                
                                // Pobierz oryginalny piksel z NEW mapy
                                const origR = newData.data[i];
                                const origG = newData.data[i + 1];
                                const origB = newData.data[i + 2];
                                
                                // Oblicz luminance (jasność)
                                const luminance = 0.299 * origR + 0.587 * origG + 0.114 * origB;
                                
                                // TYLKO na jasne piksele (luminance > 80) nałóż żółty zakreślacz!
                                // Ciemne piksele (czarny tekst) zostają PRZEZROCZYSTE - przebijają się w 100%!
                                if (luminance > 80) {
                                    // MOCNY żółty kolor - czyste żółte RGB
                                    finalDiffData.data[i] = 255;      // R - pełny czerwony
                                    finalDiffData.data[i + 1] = 255;  // G - pełny zielony
                                    finalDiffData.data[i + 2] = 0;    // B - zero niebieskiego = żółty
                                    finalDiffData.data[i + 3] = 150;  // Alpha 150 (nie 255!) - kolory z mapy przeświecają!
                                }
                            }
                        }
                    }
                });
                
                // Wstaw zmodyfikowane dane
                diffCtx.putImageData(finalDiffData, 0, 0);
            }
            
            // Zwracamy informację o różnicach
            if (differenceCount > 0) {
                differences.push({
                    type: 'graphic',
                    page: pageNum,
                    x: 0,
                    y: 0,
                    width: width,
                    height: height,
                    diffCanvas: diffCanvas,  // Canvas z różnicami
                    diffCount: differenceCount,
                    totalPixels: width * height,
                    percentage: (differenceCount / (width * height)) * 100,
                    regions: regions,
                    threshold: threshold,  // Dodajemy info o threshold
                    minArea: minArea
                });
            }
            
            return differences;
        }

        function floodFill(map, visited, startX, startY, width, height) {
            const stack = [[startX, startY]];
            let area = 0;
            let minX = startX, maxX = startX;
            let minY = startY, maxY = startY;
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const idx = y * width + x;
                
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                if (visited[idx] === 1 || map[idx] === 0) continue;
                
                visited[idx] = 1;
                area++;
                
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                
                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            
            return { area, minX, maxX, minY, maxY };
        }

        async function toggleOCRMode(mode) {
            const hybridBtn = document.getElementById('ocrHybridBtn');
            const sensitivityControl = document.getElementById('sensitivityControl');
            
            if (ocrMode === mode) {
                ocrMode = null;
                hybridBtn.classList.remove('active');
                sensitivityControl.style.display = 'none';
                clearOCROverlay();
            } else {
                ocrMode = mode;
                hybridBtn.classList.toggle('active', mode === 'hybrid');
                sensitivityControl.style.display = mode === 'hybrid' ? 'block' : 'none';
                await renderOCROverlay();
            }
        }

        async function renderOCROverlay() {
            if (!ocrMode || currentPairIndex >= pdfPairs.length) {
                clearOCROverlay();
                return;
            }
            
            let ocrData = ocrResults.get(currentPairIndex);
            
            // Jeśli nie ma canvasów, przygotuj je
            if (!ocrData) {
                await prepareCanvasesForPixelDiff(currentPairIndex);
                ocrData = ocrResults.get(currentPairIndex);
            }
            
            if (!ocrData) {
                clearOCROverlay();
                return;
            }
            
            document.querySelectorAll('.ocr-overlay').forEach(el => el.remove());
            
            const currentPage = currentPageIndex + 1;
            
            if (currentMode === 'sidebyside') {
                const oldContainer = document.getElementById('oldContainer');
                const newContainer = document.getElementById('newContainer');
                
                if (oldContainer) {
                    const oldCanvas = oldContainer.querySelector('canvas');
                    if (oldCanvas) {
                        const overlay = createOCROverlaySVG(oldCanvas, ocrData, currentPage);
                        oldContainer.appendChild(overlay);
                    }
                }
                
                if (newContainer) {
                    const newCanvas = newContainer.querySelector('canvas');
                    if (newCanvas) {
                        const overlay = createOCROverlaySVG(newCanvas, ocrData, currentPage);
                        newContainer.appendChild(overlay);
                    }
                }
            } else if (currentMode === 'toggle') {
                // W TRYBIE TOGGLE: dodaj JEDEN overlay do toggleContainer
                const toggleContainer = document.getElementById('toggleContainer');
                
                if (toggleContainer) {
                    // Znajdź pierwszy canvas (może być old lub new)
                    const canvas = toggleContainer.querySelector('canvas');
                    if (canvas) {
                        const overlay = createOCROverlaySVG(canvas, ocrData, currentPage);
                        toggleContainer.appendChild(overlay);
                    }
                }
            } else {
                // Inne tryby (overlay)
                const container = document.querySelector('.canvas-container');
                if (container) {
                    const canvas = container.querySelector('canvas');
                    if (canvas) {
                        const overlay = createOCROverlaySVG(canvas, ocrData, currentPage);
                        container.appendChild(overlay);
                    }
                }
            }
        }

        function createOCROverlaySVG(canvas, ocrData, currentPage) {
            const container = document.createElement('div');
            container.classList.add('ocr-overlay');
            container.style.position = 'absolute';
            container.style.top = '0';
            container.style.left = '0';
            container.style.width = '100%';
            container.style.height = '100%';
            container.style.pointerEvents = 'none';
            container.style.zIndex = '998';
            
            if (ocrMode === 'hybrid') {
                const pair = pdfPairs[currentPairIndex];
                
                const loadingText = document.createElement('div');
                loadingText.style.position = 'absolute';
                loadingText.style.top = '10px';
                loadingText.style.left = '10px';
                loadingText.style.color = '#ffa500';
                loadingText.style.fontSize = '20px';
                loadingText.style.fontWeight = 'bold';
                loadingText.style.background = 'rgba(0,0,0,0.8)';
                loadingText.style.padding = '10px';
                loadingText.style.borderRadius = '5px';
                loadingText.textContent = 'Obliczam pixel diff...';
                loadingText.classList.add('pixel-diff-loading');
                container.appendChild(loadingText);
                
                recalculatePixelDiff(pair, currentPage).then(pixelDiffs => {
                    container.querySelectorAll('.pixel-diff-loading').forEach(el => el.remove());
                    
                    if (pixelDiffs.length > 0 && pixelDiffs[0].diffCanvas) {
                        const diff = pixelDiffs[0];
                        const diffCanvas = diff.diffCanvas;
                        
                        // Dodaj canvas z różnicami jako overlay
                        diffCanvas.style.position = 'absolute';
                        diffCanvas.style.top = '0';
                        diffCanvas.style.left = '0';
                        diffCanvas.style.width = '100%';
                        diffCanvas.style.height = '100%';
                        diffCanvas.style.objectFit = 'contain';
                        container.appendChild(diffCanvas);
                        
                        // Żółty zakreślacz jest już namalowany BEZPOŚREDNIO w diffCanvas!
                        
                        // Dodaj informację o statystykach
                        const statsDiv = document.createElement('div');
                        statsDiv.style.position = 'absolute';
                        statsDiv.style.bottom = '10px';
                        statsDiv.style.right = '10px';
                        statsDiv.style.background = 'rgba(0,0,0,0.8)';
                        statsDiv.style.color = 'white';
                        statsDiv.style.padding = '10px';
                        statsDiv.style.borderRadius = '5px';
                        statsDiv.style.fontSize = '14px';
                        statsDiv.innerHTML = `
                            <strong>Pixel Diff Stats:</strong><br>
                            Różnice: ${diff.percentage.toFixed(2)}%<br>
                            Piksele: ${diff.diffCount.toLocaleString()} / ${diff.totalPixels.toLocaleString()}<br>
                            Threshold: ${Math.round(diff.threshold)}<br>
                            🟡 Regiony: ${diff.regions ? diff.regions.length : 0} (≥${diff.minArea}px)
                        `;
                        container.appendChild(statsDiv);
                    }
                });
            }
            
            return container;
        }

        async function prepareCanvasesForPixelDiff(pairIndex) {
            if (pairIndex >= pdfPairs.length) return;
            
            const pair = pdfPairs[pairIndex];
            
            try {
                const pixelData = {
                    canvases: []
                };
                
                for (let pageNum = 1; pageNum <= pair.totalPages; pageNum++) {
                    const oldCanvas = document.createElement('canvas');
                    const newCanvas = document.createElement('canvas');
                    
                    const scale = 2.0;
                    
                    if (pageNum <= pair.oldDoc.numPages) {
                        const page = await pair.oldDoc.getPage(pageNum);
                        const viewport = page.getViewport({scale: scale});
                        oldCanvas.width = viewport.width;
                        oldCanvas.height = viewport.height;
                        const ctx = oldCanvas.getContext('2d');
                        await page.render({canvasContext: ctx, viewport: viewport}).promise;
                    }
                    
                    if (pageNum <= pair.newDoc.numPages) {
                        const page = await pair.newDoc.getPage(pageNum);
                        const viewport = page.getViewport({scale: scale});
                        newCanvas.width = viewport.width;
                        newCanvas.height = viewport.height;
                        const ctx = newCanvas.getContext('2d');
                        await page.render({canvasContext: ctx, viewport: viewport}).promise;
                    }
                    
                    pixelData.canvases.push({
                        page: pageNum,
                        oldCanvas: oldCanvas,
                        newCanvas: newCanvas
                    });
                }
                
                ocrResults.set(pairIndex, pixelData);
                
            } catch (error) {
                console.error(`Error preparing canvases for pair ${pairIndex}:`, error);
            }
        }

        async function recalculatePixelDiff(pair, pageNum) {
            const ocrData = ocrResults.get(currentPairIndex);
            if (!ocrData || !ocrData.canvases) {
                return [];
            }
            
            const canvasData = ocrData.canvases.find(c => c.page === pageNum);
            if (!canvasData) {
                return [];
            }
            
            return comparePixels(canvasData.oldCanvas, canvasData.newCanvas, pageNum);
        }

        function clearOCROverlay() {
            document.querySelectorAll('.ocr-overlay').forEach(el => el.remove());
        }

        // FIX #3: Add "NO ICAO" group for pairs without ICAO
        function renderPairList() {
            const pairList = document.getElementById('pairListSidebar');
            pairList.innerHTML = '';

            const icaoGroups = new Map();
            pdfPairs.forEach((pair, index) => {
                const icao = pair.icao || 'NO ICAO';
                if (!icaoGroups.has(icao)) icaoGroups.set(icao, []);
                icaoGroups.get(icao).push({ pair, index });
            });

            // Sort groups: regular ICAOs first, then NO ICAO
            const sortedICAOs = Array.from(icaoGroups.keys()).sort((a, b) => {
                if (a === 'NO ICAO') return 1;
                if (b === 'NO ICAO') return -1;
                return a.localeCompare(b);
            });

            sortedICAOs.forEach((icao) => {
                const items = icaoGroups.get(icao);
                const groupDiv = document.createElement('div');
                groupDiv.className = 'icao-group';

                const header = document.createElement('div');
                header.className = icao === 'NO ICAO' ? 'icao-header no-icao' : 'icao-header';
                const icon = icao === 'NO ICAO' ? '⚠️' : '✈️';
                header.innerHTML = `<span>${icon} ${icao} (${items.length})</span><span class="arrow">▼</span>`;
                header.onclick = (e) => {
                    e.stopPropagation();
                    header.classList.toggle('collapsed');
                    filesDiv.classList.toggle('hidden');
                };
                groupDiv.appendChild(header);

                const filesDiv = document.createElement('div');
                filesDiv.className = 'icao-files';

                items.forEach(({ pair, index }) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'pair-item-sidebar';
                    if (index === currentPairIndex && selectedUnpairedOldIndex === null && selectedUnpairedNewIndex === null) {
                        itemDiv.classList.add('active');
                    }
                    if (checkedPairs.has(index)) itemDiv.classList.add('checked');

                    const checkbox = document.createElement('div');
                    checkbox.className = 'checkbox';
                    checkbox.onclick = (e) => {
                        e.stopPropagation();
                        toggleCheckbox(index);
                    };

                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'pair-name';
                    
                    let displayName = pair.name.replace(/^AD\s*2-?/i, '').trim();
                    // Usuń rozszerzenie .pdf
                    displayName = displayName.replace(/\.pdf$/i, '');
                    if (pair.icao && pair.icao !== 'NO ICAO') {
                        displayName = displayName.replace(new RegExp(`^${pair.icao}[\\s-]*`, 'i'), '').trim();
                    }
                    
                    nameDiv.innerHTML = `
                        <div class="pair-name-main">${index + 1}. ${displayName}</div>
                        <div class="pair-name-pages">${pair.totalPages}s</div>
                    `;

                    let warningIcon = null;
                    if (pair.fuzzyDistance && pair.fuzzyDistance > 0) {
                        warningIcon = document.createElement('span');
                        warningIcon.className = 'fuzzy-warning';
                        warningIcon.textContent = '⚠️';
                        warningIcon.setAttribute('data-tooltip', 'Nazwa dopasowana funkcją fuzzy matching. Upewnij się, że mapy są dobrze sparowane!');
                    }

                    // Usunięto ocrStatus - nie potrzebny dla pixel diff

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-pair-btn';
                    removeBtn.textContent = '❌';
                    removeBtn.title = 'Usuń parę';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm('Usunąć tę parę z listy?')) {
                            removePair(index);
                        }
                    };

                    itemDiv.appendChild(checkbox);
                    itemDiv.appendChild(nameDiv);
                    if (warningIcon) itemDiv.appendChild(warningIcon);
                    // itemDiv.appendChild(ocrStatus); - REMOVED
                    itemDiv.appendChild(removeBtn);
                    itemDiv.onclick = (e) => {
                        if (!e.target.closest('.checkbox') && !e.target.closest('.remove-pair-btn')) {
                            selectedUnpairedOldIndex = null;
                            selectedUnpairedNewIndex = null;
                            loadPair(index);
                        }
                    };
                    
                    filesDiv.appendChild(itemDiv);
                });

                groupDiv.appendChild(filesDiv);
                pairList.appendChild(groupDiv);
            });

            if (unpairedOld.length > 0) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'icao-group';

                let totalPages = unpairedOld.reduce((sum, item) => sum + item.totalPages, 0);
                const header = document.createElement('div');
                header.className = 'icao-header unpaired-old';
                header.innerHTML = `<span>🔴 OLD (${unpairedOld.length})</span><span class="arrow">▼</span>`;
                header.onclick = (e) => {
                    e.stopPropagation();
                    header.classList.toggle('collapsed');
                    filesDiv.classList.toggle('hidden');
                };
                groupDiv.appendChild(header);

                const filesDiv = document.createElement('div');
                filesDiv.className = 'icao-files';

                unpairedOld.forEach((item, itemIndex) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'unpaired-item-sidebar';
                    itemDiv.style.display = 'flex';
                    itemDiv.style.alignItems = 'center';
                    itemDiv.style.justifyContent = 'space-between';
                    
                    if (selectedUnpairedOldIndex === itemIndex) {
                        itemDiv.classList.add('selected');
                    }
                    itemDiv.draggable = true;
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = item.name;
                    nameSpan.style.flex = '1';
                    nameSpan.style.minWidth = '0';
                    nameSpan.style.overflow = 'hidden';
                    nameSpan.style.textOverflow = 'ellipsis';
                    nameSpan.style.whiteSpace = 'nowrap';
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '❌';
                    removeBtn.style.background = 'none';
                    removeBtn.style.border = 'none';
                    removeBtn.style.color = '#dc3545';
                    removeBtn.style.cursor = 'pointer';
                    removeBtn.style.fontSize = '0.9em';
                    removeBtn.style.padding = '2px 5px';
                    removeBtn.title = 'Usuń z listy';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        unpairedOld.splice(itemIndex, 1);
                        renderPairList();
                    };
                    
                    itemDiv.appendChild(nameSpan);
                    itemDiv.appendChild(removeBtn);
                    
                    // Kliknięcie w pojedynczą mapę OLD
                    itemDiv.onclick = () => {
                        selectedUnpairedOldIndex = itemIndex;
                        selectedUnpairedOldPage = 0;
                        selectedUnpairedNewIndex = null;
                        selectedUnpairedNewPage = null;
                        renderPairList();
                        renderUnpairedView();
                    };
                    
                    itemDiv.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', `unpaired-old-${itemIndex}`);
                        itemDiv.classList.add('dragging');
                    });
                    
                    itemDiv.addEventListener('dragend', () => {
                        itemDiv.classList.remove('dragging');
                    });
                    
                    filesDiv.appendChild(itemDiv);
                });

                groupDiv.appendChild(filesDiv);
                pairList.appendChild(groupDiv);
            }

            if (unpairedNew.length > 0) {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'icao-group';

                let totalPages = unpairedNew.reduce((sum, item) => sum + item.totalPages, 0);
                const header = document.createElement('div');
                header.className = 'icao-header unpaired-new';
                header.innerHTML = `<span>🟢 NEW (${unpairedNew.length})</span><span class="arrow">▼</span>`;
                header.onclick = (e) => {
                    e.stopPropagation();
                    header.classList.toggle('collapsed');
                    filesDiv.classList.toggle('hidden');
                };
                groupDiv.appendChild(header);

                const filesDiv = document.createElement('div');
                filesDiv.className = 'icao-files';

                unpairedNew.forEach((item, itemIndex) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'unpaired-item-sidebar';
                    itemDiv.style.display = 'flex';
                    itemDiv.style.alignItems = 'center';
                    itemDiv.style.justifyContent = 'space-between';
                    
                    if (selectedUnpairedNewIndex === itemIndex) {
                        itemDiv.classList.add('selected');
                    }
                    itemDiv.draggable = true;
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = item.name;
                    nameSpan.style.flex = '1';
                    nameSpan.style.minWidth = '0';
                    nameSpan.style.overflow = 'hidden';
                    nameSpan.style.textOverflow = 'ellipsis';
                    nameSpan.style.whiteSpace = 'nowrap';
                    
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '❌';
                    removeBtn.style.background = 'none';
                    removeBtn.style.border = 'none';
                    removeBtn.style.color = '#dc3545';
                    removeBtn.style.cursor = 'pointer';
                    removeBtn.style.fontSize = '0.9em';
                    removeBtn.style.padding = '2px 5px';
                    removeBtn.title = 'Usuń z listy';
                    removeBtn.onclick = (e) => {
                        e.stopPropagation();
                        unpairedNew.splice(itemIndex, 1);
                        renderPairList();
                    };
                    
                    itemDiv.appendChild(nameSpan);
                    itemDiv.appendChild(removeBtn);
                    
                    // Kliknięcie w pojedynczą mapę NEW
                    itemDiv.onclick = () => {
                        selectedUnpairedNewIndex = itemIndex;
                        selectedUnpairedNewPage = 0;
                        selectedUnpairedOldIndex = null;
                        selectedUnpairedOldPage = null;
                        renderPairList();
                        renderUnpairedView();
                    };
                    
                    itemDiv.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', `unpaired-new-${itemIndex}`);
                        itemDiv.classList.add('dragging');
                    });
                    
                    itemDiv.addEventListener('dragend', () => {
                        itemDiv.classList.remove('dragging');
                    });
                    
                    filesDiv.appendChild(itemDiv);
                });

                groupDiv.appendChild(filesDiv);
                pairList.appendChild(groupDiv);
            }
        }

        function toggleCheckbox(index) {
            if (checkedPairs.has(index)) {
                checkedPairs.delete(index);
            } else {
                checkedPairs.add(index);
            }
            renderPairList();
            updateStats();
        }

        async function loadPair(index) {
            if (index < 0 || index >= pdfPairs.length) return;

            currentPairIndex = index;
            currentPageIndex = 0;
            checkedPairs.add(index);

            renderPairList();
            updateStats();

            const pair = pdfPairs[index];
            
            const pageNav = document.getElementById('pageNav');
            if (pair.totalPages > 1) {
                pageNav.style.display = 'flex';
                updatePageInfo();
            } else {
                pageNav.style.display = 'none';
            }

            await renderCurrentPage();
        }

        async function renderCurrentPage() {
            const pair = pdfPairs[currentPairIndex];
            const pageNum = currentPageIndex + 1;
            const viewer = document.getElementById('viewer');
            viewer.innerHTML = '';
            viewer.style.display = '';

            document.getElementById('canvasLabel').style.display = 'block';
            document.getElementById('resetZoomBtn').style.display = 'block';
            document.getElementById('fullscreenToggleBtn').style.display = 'block';

            syncState = { zoom: 1, panX: 0, panY: 0 };
            currentRotation = 0;

            if (currentMode === 'toggle') {
                await renderToggle(pair, pageNum);
            } else if (currentMode === 'overlay') {
                await renderOverlay(pair, pageNum);
            } else {
                await renderSideBySide(pair, pageNum);
            }
            
            if (ocrMode) {
                await renderOCROverlay();
            }
        }

        async function renderToggle(pair, pageNum) {
            const viewer = document.getElementById('viewer');
            const label = document.getElementById('canvasLabel');
            
            const container = document.createElement('div');
            container.className = 'canvas-container';
            container.style.position = 'relative';
            container.id = 'toggleContainer';

            const oldCanvas = document.createElement('canvas');
            oldCanvas.id = 'toggleCanvasOld';
            
            const newCanvas = document.createElement('canvas');
            newCanvas.id = 'toggleCanvasNew';
            newCanvas.style.position = 'absolute';
            newCanvas.style.top = '0';
            newCanvas.style.left = '0';

            container.appendChild(oldCanvas);
            container.appendChild(newCanvas);
            viewer.appendChild(container);

            const scale = 3.0;

            if (pageNum <= pair.oldDoc.numPages) {
                const page = await pair.oldDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                oldCanvas.width = viewport.width;
                oldCanvas.height = viewport.height;
                const ctx = oldCanvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: viewport}).promise;
                
                await renderPDFAnnotations(container, pair.oldDoc, pageNum, oldCanvas.width, oldCanvas.height);
            }

            if (pageNum <= pair.newDoc.numPages) {
                const page = await pair.newDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                newCanvas.width = viewport.width;
                newCanvas.height = viewport.height;
                const ctx = newCanvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: viewport}).promise;
                
                const alignment = alignmentOffsets.get(currentPairIndex);
                if (alignment && (alignment.offsetX !== 0 || alignment.offsetY !== 0)) {
                    applyCanvasAlignmentFixed(newCanvas, alignment);
                }
            }

            showingOld = true;
            updateToggleView();
            addZoomToCanvas(container);
        }

        function applyCanvasAlignmentFixed(canvas, alignment) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.drawImage(canvas, 0, 0);
            
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(alignment.offsetX, alignment.offsetY);
            ctx.scale(alignment.scaleX, alignment.scaleY);
            ctx.drawImage(tempCanvas, 0, 0);
            ctx.restore();
        }

        function updateToggleView() {
            const oldCanvas = document.getElementById('toggleCanvasOld');
            const newCanvas = document.getElementById('toggleCanvasNew');
            const label = document.getElementById('canvasLabel');
            
            if (!oldCanvas || !newCanvas || !label) return;

            if (viewMode === 'old' || (viewMode === 'auto' && showingOld)) {
                oldCanvas.style.visibility = 'visible';
                oldCanvas.style.opacity = '1';
                newCanvas.style.visibility = 'hidden';
                newCanvas.style.opacity = '0';
                label.textContent = 'OLD';
                label.style.background = 'rgba(220, 53, 69, 0.8)';
            } else {
                oldCanvas.style.visibility = 'hidden';
                oldCanvas.style.opacity = '0';
                newCanvas.style.visibility = 'visible';
                newCanvas.style.opacity = '1';
                label.textContent = 'NEW';
                label.style.background = 'rgba(40, 167, 69, 0.8)';
            }
        }

        async function renderOverlay(pair, pageNum) {
            const viewer = document.getElementById('viewer');
            const label = document.getElementById('canvasLabel');
            
            const container = document.createElement('div');
            container.className = 'canvas-container';
            container.style.position = 'relative';
            container.id = 'overlayContainer';

            const oldCanvas = document.createElement('canvas');
            const newCanvas = document.createElement('canvas');
            newCanvas.style.position = 'absolute';
            newCanvas.style.top = '0';
            newCanvas.style.left = '0';

            label.textContent = 'OLD (czerwony) + NEW (zielony)';
            label.style.background = 'rgba(0,0,0,0.8)';

            const scale = 3.0;

            if (pageNum <= pair.oldDoc.numPages) {
                const page = await pair.oldDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                oldCanvas.width = viewport.width;
                oldCanvas.height = viewport.height;
                const ctx = oldCanvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: viewport}).promise;
                
                applyMonochromaticFilter(ctx, oldCanvas.width, oldCanvas.height, 'red');
            }

            if (pageNum <= pair.newDoc.numPages) {
                const page = await pair.newDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                newCanvas.width = viewport.width;
                newCanvas.height = viewport.height;
                const ctx = newCanvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: viewport}).promise;
                
                const alignment = alignmentOffsets.get(currentPairIndex);
                if (alignment && (alignment.offsetX !== 0 || alignment.offsetY !== 0)) {
                    applyCanvasAlignmentFixed(newCanvas, alignment);
                }
                
                applyMonochromaticFilter(ctx, newCanvas.width, newCanvas.height, 'green');
                
                newCanvas.style.opacity = document.getElementById('opacityRange').value / 100;
            }

            container.appendChild(oldCanvas);
            container.appendChild(newCanvas);
            viewer.appendChild(container);

            addZoomToCanvas(container);
        }

        function applyMonochromaticFilter(ctx, width, height, color) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            const whiteThreshold = 245; // Tylko bardzo białe piksele pozostają białe
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Średnia jako luminancja
                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                
                // Jeśli bardzo jasne (prawie białe) - zostaw białe
                if (luminance > whiteThreshold) {
                    data[i] = 255;
                    data[i + 1] = 255;
                    data[i + 2] = 255;
                } else {
                    // WSZYSTKIE inne kolory (także czarne) zamieniamy na czerwone/zielone
                    // Odwracamy intensywność: ciemne -> jasne kolory, jasne -> ciemne kolory
                    const invertedIntensity = 1 - (luminance / 255);
                    const colorValue = Math.floor(255 * Math.max(0.3, invertedIntensity)); // Min 30% jasności
                    
                    if (color === 'red') {
                        data[i] = colorValue;
                        data[i + 1] = 0;
                        data[i + 2] = 0;
                    } else {
                        data[i] = 0;
                        data[i + 1] = colorValue;
                        data[i + 2] = 0;
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        async function renderSideBySide(pair, pageNum) {
            const viewer = document.getElementById('viewer');
            const label = document.getElementById('canvasLabel');
            
            label.style.display = 'none';
            
            const sidebyContainer = document.createElement('div');
            sidebyContainer.className = 'sidebyside-container';
            sidebyContainer.id = 'sidebyContainer';

            const scale = 3.0;

            const leftViewer = document.createElement('div');
            leftViewer.className = 'sidebyside-viewer';
            leftViewer.id = 'leftViewer';
            
            const oldLabel = document.createElement('div');
            oldLabel.className = 'sidebyside-label old';
            oldLabel.textContent = 'OLD';
            leftViewer.appendChild(oldLabel);
            
            if (pageNum <= pair.oldDoc.numPages) {
                const containerOld = document.createElement('div');
                containerOld.className = 'canvas-container';
                containerOld.id = 'oldContainer';
                
                const canvas = document.createElement('canvas');
                const page = await pair.oldDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const ctx = canvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: viewport}).promise;
                
                containerOld.appendChild(canvas);
                
                await renderPDFAnnotations(containerOld, pair.oldDoc, pageNum, canvas.width, canvas.height);
                
                leftViewer.appendChild(containerOld);
            }
            
            const rightViewer = document.createElement('div');
            rightViewer.className = 'sidebyside-viewer';
            rightViewer.id = 'rightViewer';
            
            const newLabel = document.createElement('div');
            newLabel.className = 'sidebyside-label new';
            newLabel.textContent = 'NEW';
            rightViewer.appendChild(newLabel);
            
            if (pageNum <= pair.newDoc.numPages) {
                const containerNew = document.createElement('div');
                containerNew.className = 'canvas-container';
                containerNew.id = 'newContainer';
                
                const canvas = document.createElement('canvas');
                const page = await pair.newDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const ctx = canvas.getContext('2d');
                await page.render({canvasContext: ctx, viewport: viewport}).promise;
                
                const alignment = alignmentOffsets.get(currentPairIndex);
                if (alignment && (alignment.offsetX !== 0 || alignment.offsetY !== 0)) {
                    applyCanvasAlignmentFixed(canvas, alignment);
                }
                
                containerNew.appendChild(canvas);
                
                await renderPDFAnnotations(containerNew, pair.newDoc, pageNum, canvas.width, canvas.height);
                
                rightViewer.appendChild(containerNew);
            }

            sidebyContainer.appendChild(leftViewer);
            sidebyContainer.appendChild(rightViewer);
            viewer.appendChild(sidebyContainer);
            
            addSyncedZoomSideBySide();
        }

        function addSyncedZoomSideBySide() {
            const oldContainer = document.getElementById('oldContainer');
            const newContainer = document.getElementById('newContainer');
            const leftViewer = document.getElementById('leftViewer');
            const rightViewer = document.getElementById('rightViewer');
            const resetBtn = document.getElementById('resetZoomBtn');
            const exitBtn = document.getElementById('exitFullscreenBtn');

            if (!oldContainer || !newContainer) return;

            let isPanning = false;
            let startX = 0, startY = 0;
            let activeViewer = null;

            resetBtn.onclick = () => {
                syncState = { zoom: 1, panX: 0, panY: 0 };
                currentRotation = 0;
                updateSyncTransform();
            };

            exitBtn.onclick = () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
            };

            const handleWheel = (e, targetViewer) => {
                e.preventDefault();
                
                const rect = targetViewer.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const pointX = (x - targetViewer.scrollLeft) / syncState.zoom - syncState.panX;
                const pointY = (y - targetViewer.scrollTop) / syncState.zoom - syncState.panY;
                
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                syncState.zoom = Math.max(0.3, Math.min(5, syncState.zoom + delta));
                
                syncState.panX = (x - targetViewer.scrollLeft) / syncState.zoom - pointX;
                syncState.panY = (y - targetViewer.scrollTop) / syncState.zoom - pointY;
                
                updateSyncTransform();
            };

            const handleMouseDown = (e, viewer) => {
                isPanning = true;
                startX = e.clientX;
                startY = e.clientY;
                activeViewer = viewer;
                oldContainer.style.cursor = 'grabbing';
                newContainer.style.cursor = 'grabbing';
                e.preventDefault();
            };

            const handleMouseMove = (e) => {
                if (!isPanning) return;
                
                let dx = (e.clientX - startX) / syncState.zoom;
                let dy = (e.clientY - startY) / syncState.zoom;
                
                const radians = (currentRotation * Math.PI) / 180;
                const cos = Math.cos(-radians);
                const sin = Math.sin(-radians);
                const rotatedDx = dx * cos - dy * sin;
                const rotatedDy = dx * sin + dy * cos;
                
                const oldRect = oldContainer.getBoundingClientRect();
                const viewerRect = activeViewer.getBoundingClientRect();
                const mapFitsHorizontally = (oldRect.width * syncState.zoom) <= viewerRect.width;
                
                if (!mapFitsHorizontally) {
                    syncState.panX += rotatedDx;
                }
                syncState.panY += rotatedDy;
                
                updateSyncTransform();
                
                startX = e.clientX;
                startY = e.clientY;
            };

            const handleMouseUp = () => {
                if (isPanning) {
                    isPanning = false;
                    oldContainer.style.cursor = 'grab';
                    newContainer.style.cursor = 'grab';
                }
            };

            leftViewer.addEventListener('wheel', (e) => handleWheel(e, leftViewer));
            rightViewer.addEventListener('wheel', (e) => handleWheel(e, rightViewer));
            leftViewer.addEventListener('mousedown', (e) => handleMouseDown(e, leftViewer));
            rightViewer.addEventListener('mousedown', (e) => handleMouseDown(e, rightViewer));
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            oldContainer.style.cursor = 'grab';
            newContainer.style.cursor = 'grab';

            updateSyncTransform();
        }

        function updateSyncTransform() {
            const oldContainer = document.getElementById('oldContainer');
            const newContainer = document.getElementById('newContainer');
            
            if (oldContainer && newContainer) {
                const transform = `rotate(${currentRotation}deg) scale(${syncState.zoom}) translate(${syncState.panX}px, ${syncState.panY}px)`;
                oldContainer.style.transform = transform;
                newContainer.style.transform = transform;
                oldContainer.style.transformOrigin = 'center center';
                newContainer.style.transformOrigin = 'center center';
            }
        }

        function addZoomToCanvas(container) {
            let zoom = 1;
            let isPanning = false;
            let startX = 0, startY = 0;
            let panX = 0, panY = 0;

            const wrapper = document.getElementById('viewerWrapper');
            const resetBtn = document.getElementById('resetZoomBtn');
            const exitBtn = document.getElementById('exitFullscreenBtn');

            const applyTransform = () => {
                container.style.transform = `rotate(${currentRotation}deg) scale(${zoom}) translate(${panX}px, ${panY}px)`;
                container.style.transformOrigin = 'center center';
            };

            resetBtn.onclick = () => {
                zoom = 1;
                panX = 0;
                panY = 0;
                currentRotation = 0;
                applyTransform();
            };

            exitBtn.onclick = () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
            };

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                const newZoom = Math.max(0.3, Math.min(5, zoom + delta));
                
                zoom = newZoom;
                
                applyTransform();
            });

            container.addEventListener('mousedown', (e) => {
                isPanning = true;
                startX = e.clientX;
                startY = e.clientY;
                container.style.cursor = 'grabbing';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                
                let dx = (e.clientX - startX) / zoom;
                let dy = (e.clientY - startY) / zoom;
                
                const radians = (currentRotation * Math.PI) / 180;
                const cos = Math.cos(-radians);
                const sin = Math.sin(-radians);
                const rotatedDx = dx * cos - dy * sin;
                const rotatedDy = dx * sin + dy * cos;
                
                panX += rotatedDx;
                panY += rotatedDy;
                
                applyTransform();
                
                startX = e.clientX;
                startY = e.clientY;
            });

            document.addEventListener('mouseup', () => {
                if (isPanning) {
                    isPanning = false;
                    container.style.cursor = 'grab';
                }
            });

            container.style.cursor = 'grab';
            applyTransform();
        }

        function toggleAutoMode() {
            const autoBtn = document.getElementById('autoBtn');
            const oldBtn = document.getElementById('oldBtn');
            const newBtn = document.getElementById('newBtn');
            
            if (viewMode === 'auto' && autoToggleInterval) {
                clearInterval(autoToggleInterval);
                autoToggleInterval = null;
                viewMode = 'old';
                autoBtn.classList.remove('active');
                autoBtn.textContent = '▶️ Auto';
                oldBtn.classList.add('active-old');
                newBtn.classList.remove('active-new');
                showingOld = true;
                updateToggleView();
            } else {
                viewMode = 'auto';
                const speed = parseInt(document.getElementById('speedRange').value);
                autoToggleInterval = setInterval(() => {
                    if (currentMode === 'toggle') {
                        showingOld = !showingOld;
                        updateToggleView();
                    }
                }, speed);
                autoBtn.classList.add('active');
                autoBtn.textContent = '⏸ Auto';
                oldBtn.classList.remove('active-old');
                newBtn.classList.remove('active-new');
            }
        }

        function showOldOnly() {
            if (autoToggleInterval) {
                clearInterval(autoToggleInterval);
                autoToggleInterval = null;
            }
            
            viewMode = 'old';
            showingOld = true;
            
            const autoBtn = document.getElementById('autoBtn');
            const oldBtn = document.getElementById('oldBtn');
            const newBtn = document.getElementById('newBtn');
            
            autoBtn.classList.remove('active');
            autoBtn.textContent = '▶️ Auto';
            oldBtn.classList.add('active-old');
            newBtn.classList.remove('active-new');
            
            updateToggleView();
        }

        function showNewOnly() {
            if (autoToggleInterval) {
                clearInterval(autoToggleInterval);
                autoToggleInterval = null;
            }
            
            viewMode = 'new';
            showingOld = false;
            
            const autoBtn = document.getElementById('autoBtn');
            const oldBtn = document.getElementById('oldBtn');
            const newBtn = document.getElementById('newBtn');
            
            autoBtn.classList.remove('active');
            autoBtn.textContent = '▶️ Auto';
            oldBtn.classList.remove('active-old');
            newBtn.classList.add('active-new');
            
            updateToggleView();
        }

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            if (selectedUnpairedOldIndex !== null || selectedUnpairedNewIndex !== null) {
                renderUnpairedView();
            } else {
                renderCurrentPage();
            }
        }

        function prevPage() {
            if (currentPageIndex > 0) {
                currentPageIndex--;
                updatePageInfo();
                renderCurrentPage();
            }
        }

        function nextPage() {
            const pair = pdfPairs[currentPairIndex];
            if (currentPageIndex < pair.totalPages - 1) {
                currentPageIndex++;
                updatePageInfo();
                renderCurrentPage();
            }
        }

        function updatePageInfo() {
            const pair = pdfPairs[currentPairIndex];
            document.getElementById('pageInfo').textContent = `Strona ${currentPageIndex + 1} z ${pair.totalPages}`;
            document.querySelector('.page-nav button:first-child').disabled = currentPageIndex === 0;
            document.querySelector('.page-nav button:last-child').disabled = currentPageIndex === pair.totalPages - 1;
        }

        function updateStats() {
            document.getElementById('totalPairs').textContent = pdfPairs.length;
            document.getElementById('checkedPairs').textContent = checkedPairs.size;
            document.getElementById('currentPairNum').textContent = 
                pdfPairs.length > 0 ? `${currentPairIndex + 1}/${pdfPairs.length}` : '-';
        }

        function rotateMap(degrees) {
            currentRotation = (currentRotation + degrees) % 360;
            if (currentRotation < 0) currentRotation += 360;
            
            if (currentMode === 'sidebyside') {
                updateSyncTransform();
            } else {
                const containers = document.querySelectorAll('.canvas-container');
                containers.forEach(container => {
                    const style = window.getComputedStyle(container);
                    const matrix = style.transform;
                    
                    if (matrix && matrix !== 'none') {
                        const currentTransform = container.style.transform;
                        if (currentTransform.includes('scale')) {
                            const scaleMatch = currentTransform.match(/scale\(([\d.]+)\)/);
                            const translateMatch = currentTransform.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);
                            
                            if (scaleMatch && translateMatch) {
                                const scale = scaleMatch[1];
                                const tx = translateMatch[1];
                                const ty = translateMatch[2];
                                container.style.transform = `rotate(${currentRotation}deg) scale(${scale}) translate(${tx}px, ${ty}px)`;
                            } else {
                                container.style.transform = `rotate(${currentRotation}deg)`;
                            }
                        } else {
                            container.style.transform = `rotate(${currentRotation}deg)`;
                        }
                    } else {
                        container.style.transform = `rotate(${currentRotation}deg)`;
                    }
                    container.style.transformOrigin = 'center center';
                });
            }
            
            if (ocrMode) {
                renderOCROverlay();
            }
        }

        function toggleFullscreen() {
            const elem = document.getElementById('viewerWrapper');
            const fullscreenToggleBtn = document.getElementById('fullscreenToggleBtn');
            const exitBtn = document.getElementById('exitFullscreenBtn');
            
            if (!document.fullscreenElement) {
                elem.requestFullscreen();
                if (fullscreenToggleBtn) fullscreenToggleBtn.style.display = 'none';
                if (exitBtn) exitBtn.style.display = 'block';
            } else {
                document.exitFullscreen();
                if (fullscreenToggleBtn) fullscreenToggleBtn.style.display = 'block';
                if (exitBtn) exitBtn.style.display = 'none';
            }
        }
        
        // Listener do zmiany fullscreen
        document.addEventListener('fullscreenchange', () => {
            const fullscreenToggleBtn = document.getElementById('fullscreenToggleBtn');
            const exitBtn = document.getElementById('exitFullscreenBtn');
            
            if (document.fullscreenElement) {
                if (fullscreenToggleBtn) fullscreenToggleBtn.style.display = 'none';
                if (exitBtn) exitBtn.style.display = 'block';
            } else {
                if (fullscreenToggleBtn) fullscreenToggleBtn.style.display = 'block';
                if (exitBtn) exitBtn.style.display = 'none';
            }
        });

        // FIX #3b: COMPLETE session isolation when clicking "Nowe"
        function resetAndUpload() {
            if (autoToggleInterval) clearInterval(autoToggleInterval);
            
            // Clear ALL annotation popups from document.body
            document.querySelectorAll('.pdf-annotation-popup').forEach(el => el.remove());
            
            pdfPairs = [];
            unpairedOld = [];
            unpairedNew = [];
            currentPairIndex = 0;
            currentPageIndex = 0;
            checkedPairs.clear();
            oldFiles = [];
            newFiles = [];
            syncState = { zoom: 1, panX: 0, panY: 0 };
            viewMode = 'auto';
            selectedUnpairedOldIndex = null;
            selectedUnpairedOldPage = null;
            selectedUnpairedNewIndex = null;
            selectedUnpairedNewPage = null;
            ocrMode = null;
            ocrResults.clear();
            manualPairingOldFiles = [];
            manualPairingNewFiles = [];
            alignmentOffsets.clear();
            pdfAnnotations.clear();
            
            document.getElementById('comparisonSection').style.display = 'none';
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('compareButtonContainer').style.display = 'none';
            oldFileInput.value = '';
            newFileInput.value = '';
            updateFileInfo();
        }

        document.getElementById('speedRange').addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('speedValue').textContent = (value / 1000).toFixed(1) + 's';
            if (autoToggleInterval) {
                clearInterval(autoToggleInterval);
                const speed = parseInt(value);
                autoToggleInterval = setInterval(() => {
                    if (currentMode === 'toggle') {
                        showingOld = !showingOld;
                        updateToggleView();
                    }
                }, speed);
            }
        });

        document.getElementById('sensitivityRange').addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('sensitivityValue').textContent = value + '%';
            if (ocrMode === 'hybrid') {
                renderOCROverlay();
            }
        });

        document.getElementById('opacityRange').addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('opacityValue').textContent = value + '%';
            if (currentMode === 'overlay') {
                const newCanvas = document.querySelector('#overlayContainer canvas:last-of-type');
                if (newCanvas) newCanvas.style.opacity = value / 100;
            }
        });


        document.addEventListener('keydown', (e) => {
            if (pdfPairs.length === 0) return;
            switch(e.key) {
                case 'ArrowLeft': prevPage(); break;
                case 'ArrowRight': nextPage(); break;
                case 'ArrowUp': if (currentPairIndex > 0) loadPair(currentPairIndex - 1); break;
                case 'ArrowDown': if (currentPairIndex < pdfPairs.length - 1) loadPair(currentPairIndex + 1); break;
                case ' ': e.preventDefault(); toggleAutoMode(); break;
                case '1': setMode('toggle'); break;
                case '2': setMode('overlay'); break;
                case '3': setMode('sidebyside'); break;
            }
        });
    </script>
</body>
</html>
